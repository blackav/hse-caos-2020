# Массивы, указатели, строки

## Массивы

Массив в Си/Си++ - это **непрерывная** область памяти, в которой подряд хранятся элементы одного типа.

```
int arr1[16];
```

Размер массива равен произведению размера одного элемента на количество элементов. То есть
`sizeof(arr1) = 16 * sizeof(int)`.

Количество элементов в определении массива можно не указывать, если его можно определить из инициализатора массива.

```
int arr2[] = { 1, 2, 3 }; // размер массива равен 3
```

Массив не может содержать отрицательное число элементов, но массивы с нулем элементов допустимы.
Их размер равен 0, и они полезны в некоторых ситуациях.

Массив нельзя возвращать из функции. Если массив передается в качестве параметра в функцию,
то фактически будет передаваться указатель на начало массива. При передаче массива в качестве
параметра он не копируется.

В контекстах, где компилятору не нужно знать размер массива (например, при передаче параметров)
самый левый размер может опускаться.

```
void func1(int a[], double b[][10]);
```

Поскольку фактически передается адрес начала массива, то модификация параметров функции будет
видна извне, так как будет модифицирован массив, адрес начала которого был передан.

Массив индексируется целым числом. Начальный элемент массива имеет индекс 0, последний
элемент массива имеет индекс `count - 1`, где `count` число элементов массива.
Обращение к элементам за пределами массива ненулевого размера (отрицательными или >= count) - undefined behavior.

## Указатели

У любого указательного типа есть специальное значение `NULL`. Везде, где требуется указательный тип,
компилятор умеет преобразовывать целое число 0 ко значению `NULL`. Везде, где требуется булевское
значение (например, в условиях `if`) значение `NULL` считается ложным значением, а любое другое значение - истинным.

Однако, не гарантируется, что битовое представление указателя `NULL` содержит все нулевые биты, например, NULL
не равный всем нулевым битам возможен на процессорах с несколькими адресными пространствами.
Тем не менее, на всех типичных микропроцессорных архитектурах
(x86/x64, ARM, PPC, MIPS, SPARC) указатель `NULL` содержит все нулевые биты. Обращение по указателю `NULL` -
undefined behavior. Поэтому компилятор может предполагать, что если некоторая указательная переменная была
разыменована, она не равна `NULL`.

```
    *p = 0;
    if (!p) { // эта проверка и весь код могут быть удалены
        fprintf(stderr, "NULL pointer\n");
    }
```

Пусть дан массив некоторого типа `T` с количеством элементов `C`:
```
T arr[C];
```

Арифметические операции над указателями определены в терминах операций над индексами массива.

Само по себе имя массива `arr`, использованное в выражении, неявно преобразовывается в указатель
на начальный элемент массива.
```
T *p = arr; // то же самое, что *p = &arr[0];
```

Если указатель `p` указывает на элемент с индексом `i` (`p = &arr[i]`), то
`p + j` (прибавление целого числа к указателю) - это то же самое, что
`&arr[i + j]`. Аналогично `p - j` (вычитание целого числа из указателя) - это `&arr[i - j]`.
Если результирующий индекс `i + j` или `i - j` окажется отрицательным или большим `C`,
то результат - undefined behavior. Однако указатель на элемент, непосредственно
следующий за последним элементом массива (`&arr[C]`) допустим, хотя его нельзя
разыменовывать. Эти правила применимы также и к операциям `+=`, `-=`, `++`, `--`
над указателями.

Если указатель `p` указывает на элемент с индексом `i`, а указатель `q` - на элемент
с индексом `j` в том же самом массиве, то
```
    q - p == &arr[j] - &arr[i] = j - i
```
Если указатели указывают на элементы разных массивов - undefined behavior.
Таким образом, разность двух указателей дает разность в терминах количества
элементов массива, расположенных между этими указателями.

Операция обращения по индексу `p[i]` применима к массивам и указателям
и обозначает по определению `*(p + i)`. Если `p` указывает
в середину массива, то вполне допустимы и отрицательные индексы,
при условии, что не происходит выхода за пределы массива.

## Представление строк в Си

Строки в Си (не путать с Си++) очень часто представляются
в формате простого массива `char*`, последнее значение
которого равно `'\0'`.

Такие строки размещаются в памяти как непрерывный массив
байт. Символ с кодом `0` может встречаться в середине этого
массива. В таком случае функции, которые предназначены
**для работы со строками** будут считать этот символ концом
строки, несмотря на то, что размер массива может быть больше,
и данные после `'\0'` легко доступны.

Указатель на символ (`char *`) определяет адрес первого
символа в строке. Все остальные символы могут быть получены
инкрементом (эквивалентно - оператором `[]`) этого указателя
на заданное смещение.


```
static const char * Hello = "Hello, World!";

char first  = *Hello;        // first  = 'H'
char second = *(Hello + 1);  // second = 'e'
char third  = Hello[2];      // third  = 'l'
char last   = Hello[12];     // last   = '!'
char nullval= Hello[13];     // nullval = 0;

```

Ввиду непрерывности размещения строки в памяти, инкремент
указателя на единицу приводит к тому, что он становится
указателем на следующий символ.


```
static const char * Hello = "Hello";

for ( const char * substring = Hello;
      '\0' != *substring;
      ++substring )
{
   printf("%s\n", substring);
}

/* Вывод на экран:
Hello
ello
llo
lo
o
*/

```

В данном примере исходная строка не изменяется, а на экран
выводятся ее подстроки, получаемые сдвигом указателя на один
символ вперед. Обратите внимание, что переменная цикла
объявлена как `const char*`. В данном случае модификатор
`const` относится не к переменной `substring`, значение
которой изменяется, а к типу данных `char*`, то есть нельзя
изменять содержимое, на которое ссылается указатель.

Если требуется объявить неизменяемость самого указателя,
необходимо писать `const` после символа `*`.


```
const char * immutable_string    = "You can't modify me!";
char * const immutable_pointer   = "Value can be changed, but pointer not";
const char * const immutable_all = "Everything protected from changes";
```

## Хранение строк

Если определяется массив элементов `char`, который инициализируется строковым литералом,
то указанная строка будет размещена в массиве.

```
char str[] = "Hello";
```

Размер массива `str` будет равен 6 (5 значащих символов + `\0`-терминатор строки).
В его элементах последовательно будут размещены символы строки.
Элементы массива могут быть модифицированы.

```
    str[4] = 0;
    printf("%s", str); // получим Hell
```

Можно размещать строку в константном массиве.
```
const char str[] = "Hello";
```

В этом случае простые попытки модификации строки будут диагностированы и
запрещены компилятором. Массив `str` вполне возможно будет размещен
в памяти, закрытой на запись, и попытка обойти ограничение компилятора
приведет к падению программы.

```
    *(char*) str = 'h';  // получим segmentation fault
```

В этих двух случаях понятно, в какой области памяти будет размещена строка.
Но рассмотрим следующий пример:
```
void func(void)
{
    const char *p = "abcdefghijkl";
    // ...
}
```

Локальная переменная `p` - это указатель, она содержит адрес начала строки,
но где размещается сама строка? Этот фрагмент эквивалентен примерно
следующему:
```
static const char anonstr[] = "abcdefghijkl";
void func(void)
{
    const char *p = anonstr;
    // ...
}
```

Содержимое строки размещается в некотором массиве в памяти, доступной только на чтение,
а адрес начала массива присваивается переменной `p`. Поэтому попытка
обойти ограничения и модифицировать строку тоже приведет к падению программы.

## Обработка строк

Если программа обрабатывает строковые данные, то вряд ли в ней можно обойтись только
константными строками. Программа должна считать строковые данные откуда-то извне,
их обработать, затем записать результат. Мы будем предполагать, что обрабатываются
текстовые файлы, то есть файлы, не содержащие байт `\0`, поэтому для работы с такими
файлами можно использовать функции стандартной библиотеки языка Си.

Считанная строка должна быть размещена в памяти. Это может быть глобальный массив,
локальный массив или область памяти, выделенная динамически. В любом случае
это будет область памяти ограниченного размера. Назовем такую область памяти,
предназначенную для хранения строки, *буфером* строки. Буфер строки имеет два параметра:
указатель на начало буфера и размер буфера. Если размер буфера равен N, то в буфере
не может размещаться строка, длина которой больше N - 1, так как один байт займет символ \0
терминатор строки.

Таким образом, мы будем различать следующие понятия: строка - это цепочка байт,
заканчивающаяся байтом \0. Буфер - это область памяти, отведенная для хранения строки.

Если требуется написать функцию, которая обрабатывает строку, и результатом обработки
тоже является строка, возможны следующие варианты.

Иногда возможно обработать строку "на месте". То есть функция принимает указатель
на начало строки и модифицирует ее в соответствии с требованиями. В этом случае
неявно предполагается что размер буфера обрабатываемой строки равен длине строки + 1.
В таком случае нормально, если строка уменьшится в размере, но **недопустимо увеличение
ее размера**.

Например, рассмотрим функцию, которая преобразовывает все символы во входной строке
к нижнему регистру:
```
void tolowerstr(char *s)
{
    for (char *p = s; *p; ++p) {
        *p = tolower(*p);
    }
}
```

Используется функция `tolower`, преобразовывающая к нижнему регистру один символ,
переданный ей в качестве аргумента.

Более универсален вариант, когда в качестве результата работы функции возвращается
строка, буфер под которую выделен в динамической памяти с помощью функций
`malloc` или `realloc`. Например, рассмотрим функцию, выполняющую конкатенацию двух
входных строк:

```
char *concatenate(const char *str1, const char *str2)
{
    size_t len1 = strlen(str1);
    size_t len2 = strlen(str2);
    char *ret = malloc(len1 + len2 + 1); // не забываем \0-байт
    if (ret) {
        memcpy(ret, str1, len1);
        memcpy(ret + len1, str2, len2 + 1);
    }
    return ret;
}
```

Функция предполагает, что аргументы `str1` и `str2` не могут быть указателями NULL.
В аргументах используется ключевое слово `const`, чтобы показать,
что строки не модифицируются функцией `concatenate`.

Функция `malloc` выделяет заданный объем памяти в куче и возвращает указатель на начало.
Если `malloc` не смогла выделить память, возвращается `NULL`.
Выделенная память используется как буфер для хранения строки.

Функция `memcpy(dst,src,size)` копирует `size` байт с места в памяти, на которое указывает
`src` на место, на которое указывает `dst`. **Буфера в памяти не должны перекрываться.**

Такая функция `concatenate` всем хороша. Важно не забыть освободить выделенную память
с помощью функции `free`. Кроме того, динамическое выделение и особождение памяти - операция сложная
и займет существенное время, если обрабатывается много коротких строк.

Часто используется еще один вариант возврата обработанной строки. В этом случае функция,
обрабатывающая строку, принимает на вход два параметра буфера: адрес начала и размер.
Функция записывает в буфер строку-результат. Если строка окажется длиннее, чем
размер буфера - 1, она обрезается. В любом случае в выходной буфер дописывается
\0 байт терминатор строки. Функция может каким-либо образом сигнализировать
о том, что буфер переполнился, например, с помощью возвращаемого значения.

```
size_t concatenate(char *buf, size_t size, const char *str1, const char *str2)
{
    // здесь реализация
}
```

Эта гипотетическая функция может возвращать суммарную длину строк `str1` и `str2`.
В буфер `buf` записывается конкатенация двух строк, но не более чем `size` - 1 символ.

Если функция принимает только один параметр для записи строки-результата - адрес буфера, при этом невозможно
контролировать длину строки, которая будет записана в этот буфер, такую функцию использовать
*крайне опасно* (по меньшей мере). Например, функция `gets`, которая считывает одну строку из
стандартного потока ввода и сохраняет ее по указанному адресу, безусловно запрещена к использованию.

## Чтение строки

Для чтения одной строки из текстового файла используется функция `fgets`.
```
    char *fgets(char *buf, size_t size, FILE *fin);
```

Функция возвращает `NULL` при ошибке чтения или достижении конца файла.
В противном случае функция возвращает указатель `buf`.

Функция считывает одну строку текста из файла `fin`.
Строка текста заканчивается либо символом '\n', либо концом файла,
либо исчерпанием места в буфере `buf`. Если символ \n считан, он помещается в буфер.
В любом случае считывается не более чем size - 1 символ из входного файла.

Функцию допустимо использовать, когда есть ограничение на максимальную длину строки текста
во входном файле.


У функций семейства `scanf` есть форматное преобразование `%s`. Оно требует
указатель на буфер строки.
```
    char buf[64];
    scanf("%s", buf);
```

При чтении строки предварительно пропускаются все пробельные символы, чтение в строку
ведется либо до конца файла, либо до первого пробельного символа.
Использование преобразование %s в этом виде не позволяет контролировать число
считанных символов, поэтому **использование `%s` в таком виде недопустимо**.
Необходимо указать максимальное число считываемых символов следующим образом:

```
    char buf[64];
    scanf("%63s", buf);
```

## Вывод строки

Строку можно вывести с помощью спецификации `%s` функции семейства `printf`.
Например,

```
    printf("%s", buf);
```

Если выводится только строка, можно использовать fputs
```
    fputs(buf, stdout);
```

**Запрещено выводить строку с помощью `printf` без явного указания формата**
```
    printf(buf); // недопустимо
```

## Форматное преобразование в строку

Для форматного вывода данных в строку предназначена функция `snprintf`.
```
    int snprintf(char *buf, size_t size, const char *format, ...);
```

`buf` и `size` задают буфер для формирования строки. `snprintf` записывает
в буфер не более чем `size` - 1 символ, всегда записывая \0 в конце.
В любом случае функция `snprintf` возвращает столько символов, сколько было
бы записано в выходной поток, если бы размер буфера `buf` был неограниченным.

Пример использования функции `snprintf`.

```
size_t concatenate(char *buf, size_t size, const char *str1, const char *str2)
{
    return snprintf(buf, size, "%s%s", str1, str2);
}
```


## Форматное чтение из строки

Для форматного преобразования из строки может использоваться функция `sscanf`.
```
    int sscanf(char *str, const char *format, ...);
```

Например,
```
    sscanf(argv[1], "%d", &value);
```

В случае чтения из строки удобно использовать форматное преобразование `%n`.
```
    int value, n;
    int res = sscanf(p, "%d%n", &value, &n);
```

В случае успешного преобразования строки в число `sscanf` вернет 1, а в переменную
`n` будет записано число символов, считанных из строки при преобразовании в число.
После этого `p + n` - это позиция в строке, на которой остановилось чтение из файла.

## Контролируемое преобразование из строки в число

Часто требуется преобразовать строку в число целого или вещественного типа,
при этом проверить корректность записи числа. При этом требуется, чтобы
при чтении числа не возникало переполнение, в хвосте числа не находится "мусор".
Следущие записи считаются недопустимыми: "" (пустая строка), "   " (только пробельные символы в строке),
"1231a" (мусор в конце строки), "1 " (пробел в конце строки),
"11111111111111111111111111111111111111111111" (число не представимо значением
целого типа). Следущие записи допустимы: "12", "   -12" (пробелы перед числом допускаются).

Для такого рода преобразований используются функции `strtol` (чтение в long), `strtoll` (чтение в long long),
`strtoul` (чтение в unsigned long), `strtoull` (чтение в unsigned long long), `strtod` (чтение в double).
Они определены в заголовочном файле `<stdlib.h>`.

Рассмотрим использование `strtol`.
```
    long strtol(const char *str, char **eptr, int radix);
```

Функция возвращает преобразованное значение. При этом если возникло переполнение, в переменную `errno`
записывается код ошибки `ERANGE`.

В переменную, адрес которой передан вторым параметром, записывается указатель на первый символ, который не является
частю считанного числа, то есть либо адрес нулевого байта-терминатора, либо адрес начала "мусора" после числа.
Если в строке вообще нет цифр, сохраняется адрес строки str.

Параметр `radix` задает систему счисления для перевода. Он может принимать значения от 2 до 36.
Если `radix` равен 0, функция пытается определить систему счисления по правилам записи целых чисел языка Си
(по префиксу числа: 0x - шестнадцатеричное, 0 - восьмеричное, иначе десятичное).

Поэтому проверка корректности чтения с помощью `strtol` заключается в следующем:
* проверить, что строка не пуста
* проверить, что переменная `errno` не установлена
* проверить, что `eptr` указывает на нулевой байт

```
    // число записано в str
    char *eptr;
    errno = 0; // очищаем errno, так как при успехе errno не модифицируется
    long value = strtol(str, &eptr, 10);
    if (!*str || *eptr || errno) {
        // ошибка преобразования из строки в число
    }
```

# Инициализация выделенной памяти

В заголовочном файле `<string.h>` объявлена одна очень
полезная функция:

`void *memset(void *s, int c, size_t n)` - заполняет
массив из `n` байт, который находится по адресу `s`
**однобайтными** значениями `c` (от `0` до `0xFF`). Возвращает
указатель `s`.

Тип параметра `int c` сохраняется по историческим причинам,
на самом деле переданное значение преобразуется к
`unsigned char`.

Эту функцию можно (и нужно) вызывать после выделения памяти
для массива или буфера, иначе с большой вероятностью,
выделенная память будет содержать какие-то случайные значения.

# Динамическое выделение памяти

Функции динамического выделения и освобождения памяти определены
в заголовочном файле `<stdlib.h>`.

* `void* malloc(size_t n_bytes)` - выделяет память для
 хранения `n_bytes` байт, возвращает нетипизированный
 указатель на выделенную область

* `void free(void *pointer)` - освобождает память,
выделенную ранее функцией `malloc`

Функция `realloc` позволяет изменить размер уже выделенного блока:
```
void *realloc(void *oldptr, size_t newsize);
```
размер выделенного блока можно как увеличивать, так и уменьшать.
Функция старается, но не гарантирует, чтобы блок памяти остался по тому же
адресу. Поэтому расширение размера может перенести данные на другой адрес.

Функция `realloc` является основой для реализации *расширяемых массивов*
(в C++ им соответствует шаблонный класс `vector`).

В расширяемом массиве для каждого массива хранятся три переменных:
`data` - указатель на массив, `size` - число элементов, хранящихся в массиве,
`reserved` - число элементов, под которые выделена память.

Начальный размер расширяемого массива может быть нулевым, а может быть
равным, например, 32 байта.

```
    int    *data;
    size_t  size = 0;
    size_t  reserved = 32 / sizeof(*data);
    data = malloc(reserved * sizeof(*data));
```

Если при добавлении элемента в массив места в нем не осталось,
память под него перевыделяется:

```
    if (size == reserved) {
        int *new_data = realloc(data, (reserved *= 2) * sizeof(*data));
        if (!new_data) { // ошибка аллокации
            free(data);
            exit(1);
        }
        data = new_data;
    }
    data[size++] = newvalue;
```

В случае ошибки выделения памяти методом `realloc` память, на которую ссылается `data`
не освобождается автоматически, нужно явно вызвать от нее метод `free`.

Так как написано ниже писать нельзя, так как в случае ошибки выделения памяти, указатель
на выделенный ранее кусок потеряется и произойдет утечка памяти:

```
~~data = realloc(data, (reserved *= 2) * sizeof(*data));~~
```

# Текстовые файлы

Текстовыми мы будем называть файлы, удовлетворяющие следующим ограничениям:
* не содержит байт со значением 127;
* из значений байтов в диапазоне 0-31 допускаются только символы \t, \r, \n; в частности, не допускается байт 0;
* файл состоит из строк текста. Каждая строка текста заканчивается либо байтом \n, либо байтами \r \n;
* последняя строка в файле может не заканчиваться байтами конца строки.

Пустой текстовый файл допускается и считается, что содержит 0 строк текста.
Если текстовый файл содержит единственную строку, не завершающуюся байтами конца строки, он содержит одну строку текста.

Ваша программа при чтении должна корректно обрабатывать файлы и с концами строк в стиле DOS, и с концами строк в стиле Unix.

Когда ваша программа формирует в качестве результата работы текстовые файлы, каждая строка, в том числе и последняя,
должна завершаться единственным символов конца строки \n. Использование \r в генерируемых файлах не допускается.

Стандартные потоки `stdin`, `stdout`, `stderr` по умолчанию являются текстовыми
потоками и должны подчиняться описанным выше правилам.
